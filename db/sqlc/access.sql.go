// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: access.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const DeleteAccess = `-- name: DeleteAccess :one
DELETE FROM "access" WHERE "id" = $1 RETURNING id, system, "table", type
`

func (q *Queries) DeleteAccess(ctx context.Context, id uuid.UUID) (*Access, error) {
	row := q.db.QueryRow(ctx, DeleteAccess, id)
	var i Access
	err := row.Scan(
		&i.ID,
		&i.System,
		&i.Table,
		&i.Type,
	)
	return &i, err
}

const FindAccess = `-- name: FindAccess :many
SELECT id, system, "table", type FROM  "access" WHERE "system" = $1 OR "table" LIKE $2 ORDER BY "table"
`

type FindAccessParams struct {
	System uuid.UUID `db:"system" json:"system"`
	Table  string    `db:"table" json:"table"`
}

func (q *Queries) FindAccess(ctx context.Context, arg *FindAccessParams) ([]*Access, error) {
	rows, err := q.db.Query(ctx, FindAccess, arg.System, arg.Table)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Access{}
	for rows.Next() {
		var i Access
		if err := rows.Scan(
			&i.ID,
			&i.System,
			&i.Table,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FindAccessPage = `-- name: FindAccessPage :many
SELECT id, system, "table", type FROM  "access" WHERE "system" = $1 OR "table" LIKE $2 ORDER BY "table" LIMIT $3 OFFSET $4
`

type FindAccessPageParams struct {
	System uuid.UUID `db:"system" json:"system"`
	Table  string    `db:"table" json:"table"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) FindAccessPage(ctx context.Context, arg *FindAccessPageParams) ([]*Access, error) {
	rows, err := q.db.Query(ctx, FindAccessPage,
		arg.System,
		arg.Table,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Access{}
	for rows.Next() {
		var i Access
		if err := rows.Scan(
			&i.ID,
			&i.System,
			&i.Table,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAccess = `-- name: GetAccess :one
SELECT id, system, "table", type FROM "access" WHERE "id" = $1 LIMIT 1
`

func (q *Queries) GetAccess(ctx context.Context, id uuid.UUID) (*Access, error) {
	row := q.db.QueryRow(ctx, GetAccess, id)
	var i Access
	err := row.Scan(
		&i.ID,
		&i.System,
		&i.Table,
		&i.Type,
	)
	return &i, err
}

const ListAccess = `-- name: ListAccess :many
SELECT id, system, "table", type FROM "access" ORDER BY "table"
`

func (q *Queries) ListAccess(ctx context.Context) ([]*Access, error) {
	rows, err := q.db.Query(ctx, ListAccess)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Access{}
	for rows.Next() {
		var i Access
		if err := rows.Scan(
			&i.ID,
			&i.System,
			&i.Table,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAccessPage = `-- name: ListAccessPage :many
SELECT id, system, "table", type FROM "access" ORDER BY "table" LIMIT $1 OFFSET $2
`

type ListAccessPageParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListAccessPage(ctx context.Context, arg *ListAccessPageParams) ([]*Access, error) {
	rows, err := q.db.Query(ctx, ListAccessPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Access{}
	for rows.Next() {
		var i Access
		if err := rows.Scan(
			&i.ID,
			&i.System,
			&i.Table,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const NewAccess = `-- name: NewAccess :one
INSERT INTO "access" ("system", "table", "type") VALUES ($1, $2, $3) RETURNING id, system, "table", type
`

type NewAccessParams struct {
	System uuid.UUID `db:"system" json:"system"`
	Table  string    `db:"table" json:"table"`
	Type   []string  `db:"type" json:"type"`
}

func (q *Queries) NewAccess(ctx context.Context, arg *NewAccessParams) (*Access, error) {
	row := q.db.QueryRow(ctx, NewAccess, arg.System, arg.Table, arg.Type)
	var i Access
	err := row.Scan(
		&i.ID,
		&i.System,
		&i.Table,
		&i.Type,
	)
	return &i, err
}

const UpdateAccess = `-- name: UpdateAccess :one
UPDATE "access" SET "type" = $2 WHERE "id" = $1 RETURNING id, system, "table", type
`

type UpdateAccessParams struct {
	ID   uuid.UUID `db:"id" json:"id"`
	Type []string  `db:"type" json:"type"`
}

func (q *Queries) UpdateAccess(ctx context.Context, arg *UpdateAccessParams) (*Access, error) {
	row := q.db.QueryRow(ctx, UpdateAccess, arg.ID, arg.Type)
	var i Access
	err := row.Scan(
		&i.ID,
		&i.System,
		&i.Table,
		&i.Type,
	)
	return &i, err
}
