// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: group_access.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const DeleteGroupAccess = `-- name: DeleteGroupAccess :one
DELETE FROM "group_access" WHERE "group_id" = $1 AND "access_id" = $2 RETURNING group_id, access_id
`

type DeleteGroupAccessParams struct {
	GroupID  uuid.UUID `db:"group_id" json:"group_id"`
	AccessID uuid.UUID `db:"access_id" json:"access_id"`
}

func (q *Queries) DeleteGroupAccess(ctx context.Context, arg *DeleteGroupAccessParams) (*GroupAccess, error) {
	row := q.db.QueryRow(ctx, DeleteGroupAccess, arg.GroupID, arg.AccessID)
	var i GroupAccess
	err := row.Scan(&i.GroupID, &i.AccessID)
	return &i, err
}

const FindGroupAccess = `-- name: FindGroupAccess :many
SELECT group_id, access_id FROM "group_access" WHERE "group_id" = $1 OR "access_id" = $2
`

type FindGroupAccessParams struct {
	GroupID  uuid.UUID `db:"group_id" json:"group_id"`
	AccessID uuid.UUID `db:"access_id" json:"access_id"`
}

func (q *Queries) FindGroupAccess(ctx context.Context, arg *FindGroupAccessParams) ([]*GroupAccess, error) {
	rows, err := q.db.Query(ctx, FindGroupAccess, arg.GroupID, arg.AccessID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GroupAccess{}
	for rows.Next() {
		var i GroupAccess
		if err := rows.Scan(&i.GroupID, &i.AccessID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FindGroupAccessPage = `-- name: FindGroupAccessPage :many
SELECT group_id, access_id FROM "group_access" WHERE "group_id" = $1 OR "access_id" = $2 LIMIT $3 OFFSET $4
`

type FindGroupAccessPageParams struct {
	GroupID  uuid.UUID `db:"group_id" json:"group_id"`
	AccessID uuid.UUID `db:"access_id" json:"access_id"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) FindGroupAccessPage(ctx context.Context, arg *FindGroupAccessPageParams) ([]*GroupAccess, error) {
	rows, err := q.db.Query(ctx, FindGroupAccessPage,
		arg.GroupID,
		arg.AccessID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GroupAccess{}
	for rows.Next() {
		var i GroupAccess
		if err := rows.Scan(&i.GroupID, &i.AccessID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetGroupAccess = `-- name: GetGroupAccess :one
SELECT group_id, access_id FROM "group_access" WHERE "group_id" = $1 AND "access_id" = $2 LIMIT 1
`

type GetGroupAccessParams struct {
	GroupID  uuid.UUID `db:"group_id" json:"group_id"`
	AccessID uuid.UUID `db:"access_id" json:"access_id"`
}

func (q *Queries) GetGroupAccess(ctx context.Context, arg *GetGroupAccessParams) (*GroupAccess, error) {
	row := q.db.QueryRow(ctx, GetGroupAccess, arg.GroupID, arg.AccessID)
	var i GroupAccess
	err := row.Scan(&i.GroupID, &i.AccessID)
	return &i, err
}

const NewGroupAccess = `-- name: NewGroupAccess :one
INSERT INTO "group_access" ("group_id", "access_id") VALUES ($1, $2) RETURNING group_id, access_id
`

type NewGroupAccessParams struct {
	GroupID  uuid.UUID `db:"group_id" json:"group_id"`
	AccessID uuid.UUID `db:"access_id" json:"access_id"`
}

func (q *Queries) NewGroupAccess(ctx context.Context, arg *NewGroupAccessParams) (*GroupAccess, error) {
	row := q.db.QueryRow(ctx, NewGroupAccess, arg.GroupID, arg.AccessID)
	var i GroupAccess
	err := row.Scan(&i.GroupID, &i.AccessID)
	return &i, err
}
