// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: session.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const DeleteSession = `-- name: DeleteSession :one
DELETE FROM "session" WHERE "id" = $1 RETURNING id, "user", token, ip, agent, created_at, expires_at
`

func (q *Queries) DeleteSession(ctx context.Context, id uuid.UUID) (*Session, error) {
	row := q.db.QueryRow(ctx, DeleteSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.User,
		&i.Token,
		&i.Ip,
		&i.Agent,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return &i, err
}

const FindSession = `-- name: FindSession :many
SELECT id, "user", token, ip, agent, created_at, expires_at FROM "session" WHERE "user" = $1
`

func (q *Queries) FindSession(ctx context.Context, user uuid.UUID) ([]*Session, error) {
	rows, err := q.db.Query(ctx, FindSession, user)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.User,
			&i.Token,
			&i.Ip,
			&i.Agent,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSession = `-- name: GetSession :one
SELECT id, "user", token, ip, agent, created_at, expires_at FROM "session" WHERE "id" = $1 LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, id uuid.UUID) (*Session, error) {
	row := q.db.QueryRow(ctx, GetSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.User,
		&i.Token,
		&i.Ip,
		&i.Agent,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return &i, err
}

const ListSession = `-- name: ListSession :many
SELECT id, "user", token, ip, agent, created_at, expires_at FROM "session" ORDER BY "created_at"
`

func (q *Queries) ListSession(ctx context.Context) ([]*Session, error) {
	rows, err := q.db.Query(ctx, ListSession)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.User,
			&i.Token,
			&i.Ip,
			&i.Agent,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSessionPage = `-- name: ListSessionPage :many
SELECT id, "user", token, ip, agent, created_at, expires_at FROM "session" ORDER BY "created_at" LIMIT $1 OFFSET $2
`

type ListSessionPageParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListSessionPage(ctx context.Context, arg *ListSessionPageParams) ([]*Session, error) {
	rows, err := q.db.Query(ctx, ListSessionPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.User,
			&i.Token,
			&i.Ip,
			&i.Agent,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const NewSession = `-- name: NewSession :one
INSERT INTO "session" ("user", "token", "ip", "agent", "expires_at") VALUES ($1, $2, $3, $4, $5) RETURNING id, "user", token, ip, agent, created_at, expires_at
`

type NewSessionParams struct {
	User      uuid.UUID `db:"user" json:"user"`
	Token     string    `db:"token" json:"token"`
	Ip        string    `db:"ip" json:"ip"`
	Agent     string    `db:"agent" json:"agent"`
	ExpiresAt time.Time `db:"expires_at" json:"expires_at"`
}

func (q *Queries) NewSession(ctx context.Context, arg *NewSessionParams) (*Session, error) {
	row := q.db.QueryRow(ctx, NewSession,
		arg.User,
		arg.Token,
		arg.Ip,
		arg.Agent,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.User,
		&i.Token,
		&i.Ip,
		&i.Agent,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return &i, err
}
